package generator

import (
	"bytes"
	"fmt"
	"github.com/expgo/ag"
	"github.com/expgo/ag/api"
	"github.com/expgo/factory"
	"github.com/expgo/generic/stream"
	"golang.org/x/tools/imports"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

func filterTypedAnnotation(typedAnnotations []*api.TypedAnnotation, annotationMap map[string][]api.AnnotationType) []*api.TypedAnnotation {
	filteredAnnotations := make([]*api.TypedAnnotation, 0)
	for _, ta := range typedAnnotations {
		if ta.Annotations != nil {
			for name, annotationTypes := range annotationMap {
				if an := ta.Annotations.FindAnnotationByName(name); an != nil {
					if stream.Must(stream.Of(annotationTypes).Contains(ta.Type, func(x, y api.AnnotationType) (bool, error) {
						return x == y, nil
					})) {
						filteredAnnotations = append(filteredAnnotations, ta)
					}
				}
			}
		}
	}

	return filteredAnnotations
}

func GenerateFile(filename string, outputSuffix string) {
	factories := factory.FindInterfaces[api.GeneratorFactory]()
	if len(factories) == 0 {
		println("No GeneratorFactory was found for the annotation generator.")
		return
	}

	typeMaps := map[api.AnnotationType]stream.Stream[string]{}
	for _, f := range factories {
		annotations := f.Annotations()
		for name, types := range annotations {
			for _, t := range types {
				typeMaps[t] = typeMaps[t].Append(name)
			}
		}
	}

	typedAnnotations, packageName, err := ag.ParseFile(filename, typeMaps)
	if err != nil {
		panic(err)
		return
	}

	if len(typedAnnotations) == 0 {
		return
	}

	gens := []api.Generator{}

	for _, f := range factories {
		if ftas := filterTypedAnnotation(typedAnnotations, f.Annotations()); len(ftas) > 0 {
			gen, e := f.New(ftas)
			if e != nil {
				panic(e)
			}
			if gen != nil {
				gens = append(gens, gen)
			}
		}
	}

	if len(gens) == 0 {
		println("No annotation found.")
		return
	}

	if len(gens) > 0 {
		buf := bytes.NewBuffer([]byte{})

		plugins := []string{}
		for _, gen := range gens {
			t := reflect.TypeOf(gen)
			if t.Kind() == reflect.Ptr {
				t = t.Elem()
			}
			plugins = append(plugins, t.PkgPath())
		}

		println("run with under plugins: \n", strings.Join(plugins, "\n"))

		buf.WriteString("// Code generated by https://github.com/expgo/ag DO NOT EDIT.\n")
		buf.WriteString("// Plugins: \n")
		for _, plugin := range plugins {
			buf.WriteString(fmt.Sprintf("//   - %s \n", plugin))
		}
		buf.WriteString("\n\n")

		// write package
		buf.WriteString("package " + packageName)
		buf.WriteString("\n\n")

		buf.WriteString("import (\n")
		for _, gen := range gens {
			importList := gen.GetImports()
			for _, imp := range importList {
				buf.WriteString("\t\"" + imp + "\"\n")
			}
		}
		buf.WriteString(")\n\n")

		for _, gen := range gens {
			err = gen.WriteConst(buf)
			if err != nil {
				panic(err)
			}
		}
		buf.WriteString("\n\n")

		for _, gen := range gens {
			err = gen.WriteInitFunc(buf)
			if err != nil {
				panic(err)
			}
		}
		buf.WriteString("\n\n")

		for _, gen := range gens {
			err = gen.WriteBody(buf)
			if err != nil {
				panic(err)
			}
		}

		formatted, err := imports.Process(packageName, buf.Bytes(), nil)
		if err != nil {
			panic(fmt.Errorf("generate: error formatting code %s\n\n%s", err, buf.String()))
		}

		outFilePath := fmt.Sprintf("%s%s.go", strings.TrimSuffix(filename, filepath.Ext(filename)), outputSuffix)
		if strings.HasSuffix(filename, "_test.go") {
			outFilePath = strings.Replace(outFilePath, "_test"+outputSuffix+".go", outputSuffix+"_test.go", 1)
		}

		mode := int(0o644)
		err = os.WriteFile(outFilePath, formatted, os.FileMode(mode))
		if err != nil {
			panic(fmt.Errorf("failed writing to file %s: %s", outFilePath, err))
		}
		println("Finish write : " + outFilePath)
	}
}
