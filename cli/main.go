package main

import (
	"bytes"
	"flag"
	"fmt"
	"github.com/expgo/ag"
	"github.com/expgo/factory"
	"github.com/expgo/generic/stream"
	"golang.org/x/tools/imports"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

func filterTypedAnnotation(typedAnnotations []*ag.TypedAnnotation, annotationMap map[string][]ag.AnnotationType) []*ag.TypedAnnotation {
	filteredAnnotations := make([]*ag.TypedAnnotation, 0)
	for _, ta := range typedAnnotations {
		if ta.Annotations != nil {
			for name, annotationTypes := range annotationMap {
				if an := ta.Annotations.FindAnnotationByName(name); an != nil {
					if stream.Must(stream.Of(annotationTypes).Contains(ta.Type, func(x, y ag.AnnotationType) (bool, error) {
						return x == y, nil
					})) {
						filteredAnnotations = append(filteredAnnotations, ta)
					}
				}
			}
		}
	}

	return filteredAnnotations
}

func GenerateFile(filename string, outputSuffix string) {

	factories := factory.FindInterfaces[ag.GeneratorFactory]()
	typeMaps := map[ag.AnnotationType]stream.Stream[string]{}
	for _, f := range factories {
		annotations := f.Annotations()
		for name, types := range annotations {
			for _, t := range types {
				typeMaps[t] = typeMaps[t].Append(name)
			}
		}
	}

	typedAnnotations, packageName, err := ag.ParseFile(filename, typeMaps)
	if err != nil {
		panic(err)
		return
	}

	if len(typedAnnotations) == 0 {
		return
	}

	gens := []ag.Generator{}

	for _, f := range factories {
		if ftas := filterTypedAnnotation(typedAnnotations, f.Annotations()); len(ftas) > 0 {
			gens = append(gens, f.New(ftas))
		}
	}

	if len(gens) > 0 {
		buf := bytes.NewBuffer([]byte{})

		buf.WriteString("// Code generated by https://github.com/expgo/ag DO NOT EDIT.\n")
		buf.WriteString("// Plugins: \n")
		for _, gen := range gens {
			t := reflect.TypeOf(gen)
			buf.WriteString(fmt.Sprintf("//   - %s \n", t.PkgPath()))
		}

		// write package
		buf.WriteString("package " + packageName)
		buf.WriteString("\n\n")

		buf.WriteString("import (\n")
		for _, gen := range gens {
			importList := gen.GetImports()
			for _, imp := range importList {
				buf.WriteString("\t\"" + imp + "\"\n")
			}
		}
		buf.WriteString(")\n\n")

		for _, gen := range gens {
			err = gen.WriteConst(buf)
			if err != nil {
				panic(err)
			}
		}
		buf.WriteString("\n\n")

		for _, gen := range gens {
			err = gen.WriteInitFunc(buf)
			if err != nil {
				panic(err)
			}
		}
		buf.WriteString("\n\n")

		for _, gen := range gens {
			err = gen.WriteBody(buf)
			if err != nil {
				panic(err)
			}
		}

		formatted, err := imports.Process(packageName, buf.Bytes(), nil)
		if err != nil {
			panic(fmt.Errorf("generate: error formatting code %s\n\n%s", err, buf.String()))
		}

		outFilePath := fmt.Sprintf("%s%s.go", strings.TrimSuffix(filename, filepath.Ext(filename)), outputSuffix)
		if strings.HasSuffix(filename, "_test.go") {
			outFilePath = strings.Replace(outFilePath, "_test"+outputSuffix+".go", outputSuffix+"_test.go", 1)
		}

		mode := int(0o644)
		err = os.WriteFile(outFilePath, formatted, os.FileMode(mode))
		if err != nil {
			panic(fmt.Errorf("failed writing to file %s: %s", outFilePath, err))
		}
	}
}

type Plugins []string

// String 是 flag.Value 接口的一部分，它返回值的默认文本表示形式
func (p *Plugins) String() string {
	return strings.Join(*p, ",")
}

func (p *Plugins) Set(value string) error {
	*p = append(*p, value)
	return nil
}

func main() {
	var filename string
	var fileSuffix string
	var plugins Plugins

	flag.StringVar(&filename, "file", "", "The file is used to generate the annotation file.")
	flag.StringVar(&fileSuffix, "file-suffix", "_ag", "Changes the default filename suffix of _ag to something else.")
	flag.Var(&plugins, "plugin", "Add extended plugins to the Annotation Generator.")

	flag.Parse()

	if len(filename) == 0 {
		filename, _ = os.LookupEnv("GOFILE")

		if len(filename) == 0 {
			fmt.Fprintf(os.Stdout, "Usage of %s:\n", os.Args[0])
			flag.PrintDefaults()
			return
		}
	}

	println(plugins.String())

	GenerateFile(filename, fileSuffix)
}
